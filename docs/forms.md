# Формы в интерфейсе Codew

Этот документ описывает паттерны, используемые в формах после рефакторинга формы комнат (коммит `4598269f7`), и служит шпаргалкой по тому, как собирать новые формы в приложении.

## Хук `useForm`

`useForm` из `@/shared/forms` объединяет все обязанности, связанные с серверным действием формы, локальным состоянием и сбросом данных после успеха. В типичном компоненте он используется так:

```ts
const { formValue, set, action, state, isPending, reset } = useForm(
  room ?? {},
  updateRoomAction,
  roomActionIdleState,
  handleSuccess,
  INITIAL_ROOM,
);
```

Аргументы:

1. **Текущие данные сущности.** Используем `{} / nullish` для форм создания и `entity` — для редактирования. Объект можно безопасно деструктурировать, `useForm` сам объединит значения.
2. **Серверное действие.** Функция `action(prevState, formData)`, которая возвращает `ActionState`. Её можно импортировать непосредственно в компонент формы или пробрасывать из обёртки.
3. **Начальный `ActionState`.** Структура с `status`, `fieldErrors`, `message` и т. п., которую форма показывает до первой отправки.
4. **`onSuccess`.** Колбэк, который вызывается после успешного завершения `action`. В нём закрываем диалог, перезапрашиваем список, показываем тосты и т. д.
5. **Дефолтные значения формы.** Объект с теми полями, которые должны быть заполнены при первом рендере. Его храним рядом с компонентом формы, чтобы значения были видны контрибьюторам.

Возвращаемые значения:

- **`formValue`** — итоговый объект, собранный из дефолтов, текущей сущности и локальных изменений.
- **`set`** — фабрика сеттеров: `set("name")(value)` обновит локальное состояние и автоматически перерендерит форму.
- **`action`** — функция, передающаяся в `<form action={action}>`.
- **`state`** — последнее значение, возвращённое серверным действием. Используем для отображения ошибок и сервисных сообщений.
- **`isPending`** — флаг отправки (например, для блокировки инпутов и кнопок).
- **`reset`** — ручной сброс локальных правок (помимо автоматического сброса после успеха).

> `useForm` очищает локальное состояние и вызывает `onSuccess` только после успешной отправки. Ошибки сервера попадают в `state` без необходимости дополнительной обработки.

## Пошаговая сборка формы

1. **Определяем дефолты рядом с компонентом.** Например, `const INITIAL_ROOM = { ... }`. Не добавляем новые значения в `shared/forms` — каждое доменное значение живёт вместе со своей формой.
2. **Вызываем `useForm`.** Передаём актуальные данные сущности (или пустой объект), серверное действие, `idleState`, `onSuccess` и дефолты.
3. **Настраиваем `<form action={action}>`.** Все отправки происходят через серверный `action`; дополнительных обёрток не требуется.
4. **Подключаем инпуты к `formValue`.** Значения берём из `formValue.field`, обновляем через `set("field")(newValue)`, а `isPending` используем для дизейблов.
5. **Обрабатываем ошибки.** `state.fieldErrors` и `state.message` напрямую прокидываем в MUI компоненты (`error`, `helperText`, `Alert`).
6. **Поддерживаем скрытые значения.** Например, булевые флаги отправляем через скрытые `<input>` с `formValue.flag ? "true" : "false"`, чтобы сервер получил корректные строки.
7. **Эффекты успеха — снаружи.** Форма не закрывает диалог и не показывает тосты самостоятельно; `onSuccess` решает родитель.

## Композиция и зависимости

Предпочтительно передавать в форму конкретные зависимости (экшен, заголовки, обработчики), а не флаг «режима». Например, создаём две тонкие обёртки:

```tsx
export function CreateRoomFormDialog(props: BaseProps) {
  return (
    <RoomFormDialog
      {...props}
      room={null}
      formAction={createRoomAction}
      onSuccess={() => props.onSuccess("Комната создана.")}
      formTitle="Новая комната"
      submitLabel="Создать"
    />
  );
}

export function UpdateRoomFormDialog(props: BaseProps & { room: SerializedRoom }) {
  return (
    <RoomFormDialog
      {...props}
      formAction={updateRoomAction}
      onSuccess={() => props.onSuccess("Настройки сохранены.")}
      formTitle="Настройки комнаты"
      submitLabel="Сохранить"
    />
  );
}
```

Так форма остаётся чистой и ничего не знает о сценарии, в котором её используют. Родитель решает, что показать в `onSuccess`, какие подписи использовать и какую сущность редактировать.

## Контрольный список перед отправкой

- [ ] Дефолтные значения объявлены рядом с компонентом, а не в общих модулях.
- [ ] Все поля читают данные из `formValue` и обновляются через `set`.
- [ ] Серверное действие подключено к `<form action={action}>`.
- [ ] Ошибки из `state` отображаются прямо в форме.
- [ ] Форма не управляет закрытием диалога и побочными эффектами успеха — они в `onSuccess` родителя.

Следуя этим правилам, формы остаются предсказуемыми, легко тестируются и переиспользуются в разных сценариях без дублирования логики.
